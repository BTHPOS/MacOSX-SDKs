.TH "MPSNNFilterNode" 3 "Sat May 12 2018" "Version MetalPerformanceShaders-116" "MetalPerformanceShaders.framework" \" -*- nroff -*-
.ad l
.nh
.SH NAME
MPSNNFilterNode
.SH SYNOPSIS
.br
.PP
.PP
\fC#import <MPSNNGraphNodes\&.h>\fP
.PP
Inherits NSObject\&.
.PP
Inherited by \fBMPSCNNBatchNormalizationNode\fP, \fBMPSCNNConvolutionNode\fP, \fBMPSCNNDilatedPoolingMaxNode\fP, \fBMPSCNNDropoutNode\fP, \fBMPSCNNInstanceNormalizationNode\fP, \fBMPSCNNLogSoftMaxNode\fP, \fBMPSCNNLossNode\fP, \fBMPSCNNNeuronNode\fP, \fBMPSCNNNormalizationNode\fP, \fBMPSCNNPoolingNode\fP, \fBMPSCNNSoftMaxNode\fP, \fBMPSCNNUpsamplingBilinearNode\fP, \fBMPSCNNUpsamplingNearestNode\fP, \fBMPSCNNYOLOLossNode\fP, \fBMPSNNBinaryArithmeticNode\fP, \fBMPSNNConcatenationNode\fP, \fBMPSNNGradientFilterNode\fP, and \fBMPSNNScaleNode\fP\&.
.SS "Instance Methods"

.in +1c
.ti -1c
.RI "(nonnull instancetype) \- \fBinit\fP"
.br
.ti -1c
.RI "(\fBMPSNNGradientFilterNode\fP *__nonnull) \- \fBgradientFilterWithSource:\fP"
.br
.ti -1c
.RI "(\fBMPSNNGradientFilterNode\fP *__nonnull) \- \fBgradientFilterWithSources:\fP"
.br
.ti -1c
.RI "(NSArray< \fBMPSNNGradientFilterNode\fP * > *__nonnull) \- \fBgradientFiltersWithSources:\fP"
.br
.ti -1c
.RI "(NSArray< \fBMPSNNGradientFilterNode\fP * > *__nonnull) \- \fBgradientFiltersWithSource:\fP"
.br
.in -1c
.SS "Properties"

.in +1c
.ti -1c
.RI "\fBMPSNNImageNode\fP * \fBresultImage\fP"
.br
.ti -1c
.RI "\fBMPSNNStateNode\fP * \fBresultState\fP"
.br
.ti -1c
.RI "NSArray< \fBMPSNNStateNode\fP * > * \fBresultStates\fP"
.br
.ti -1c
.RI "id< \fBMPSNNPadding\fP > \fBpaddingPolicy\fP"
.br
.ti -1c
.RI "NSString * \fBlabel\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
\fBA\fP placeholder node denoting a neural network filter stage  There are as many \fBMPSNNFilterNode\fP subclasses as there are MPS neural network filter objects\&. Make one of those\&. This class defines an polymorphic interface for them\&. 
.SH "Method Documentation"
.PP 
.SS "\- (NSArray <\fBMPSNNGradientFilterNode\fP*> * __nonnull) gradientFiltersWithSource: (\fBMPSNNImageNode\fP *__nonnull) gradientImage"
Return multiple gradient versions of the filter  MPSNNFilters that consume multiple inputs generally result in multiple conjugate filters for the gradient computation at the end of training\&. For example, a single concatenation operation that concatenates multple images will result in an array of slice operators that carve out subsections of the input gradient image\&. 
.PP
Reimplemented in \fBMPSNNGradientFilterNode\fP\&.
.SS "\- (NSArray <\fBMPSNNGradientFilterNode\fP*> * __nonnull) gradientFiltersWithSources: (NSArray< \fBMPSNNImageNode\fP * > *__nonnull) gradientImages"
Return multiple gradient versions of the filter  MPSNNFilters that consume multiple inputs generally result in multiple conjugate filters for the gradient computation at the end of training\&. For example, a single concatenation operation that concatenates multple images will result in an array of slice operators that carve out subsections of the input gradient image\&. 
.PP
Reimplemented in \fBMPSNNBinaryArithmeticNode\fP, and \fBMPSNNGradientFilterNode\fP\&.
.SS "\- (\fBMPSNNGradientFilterNode\fP*__nonnull) gradientFilterWithSource: (\fBMPSNNImageNode\fP *__nonnull) gradientImage"
Return the gradient (backwards) version of this filter\&.  The backwards training version of the filter will be returned\&. The non-gradient image and state arguments for the filter are automatically obtained from the target\&. 
.PP
\fBParameters:\fP
.RS 4
\fIgradientImage\fP The gradient images corresponding with the resultImage of the target 
.RE
.PP

.PP
Reimplemented in \fBMPSNNGradientFilterNode\fP\&.
.SS "\- (\fBMPSNNGradientFilterNode\fP*__nonnull) gradientFilterWithSources: (NSArray< \fBMPSNNImageNode\fP * > *__nonnull) gradientImages"
Return the gradient (backwards) version of this filter\&.  The backwards training version of the filter will be returned\&. The non-gradient image and state arguments for the filter are automatically obtained from the target\&. 
.PP
\fBParameters:\fP
.RS 4
\fIgradientImages\fP The gradient images corresponding with the resultImage of the target 
.RE
.PP

.PP
Reimplemented in \fBMPSCNNYOLOLossNode\fP, \fBMPSNNConcatenationNode\fP, \fBMPSCNNLossNode\fP, \fBMPSNNBinaryArithmeticNode\fP, and \fBMPSNNGradientFilterNode\fP\&.
.SS "\- (nonnull instancetype) init "

.PP
Reimplemented in \fBMPSCNNNeuronGradientNode\fP, and \fBMPSCNNNeuronNode\fP\&.
.SH "Property Documentation"
.PP 
.SS "\- label\fC [read]\fP, \fC [write]\fP, \fC [atomic]\fP, \fC [copy]\fP"
\fBA\fP string to help identify this object\&. 
.SS "\- (id<\fBMPSNNPadding\fP>) paddingPolicy\fC [read]\fP, \fC [write]\fP, \fC [nonatomic]\fP, \fC [retain]\fP"
The padding method used for the filter node  The padding policy configures how the filter centers the region of interest in the source image\&. It principally is responsible for setting the \fBMPSCNNKernel\&.offset\fP and the size of the image produced, and sometimes will also configure \&.sourceFeatureChannelOffset, \&.sourceFeatureChannelMaxCount, and \&.edgeMode\&. It is permitted to set any other filter properties as needed using a custom padding policy\&. The default padding policy varies per filter to conform to consensus expectation for the behavior of that filter\&. In some cases, pre-made padding policies are provided to match the behavior of common neural networking frameworks with particularly complex or unexpected behavior for specific nodes\&. See \fBMPSNNDefaultPadding\fP class methods in \fBMPSNeuralNetworkTypes\&.h\fP for more\&.
.PP
BUG: MPS doesn't provide a good way to reset the \fBMPSKernel\fP properties in the context of a \fBMPSNNGraph\fP after the kernel is finished encoding\&. These values carry on to the next time the graph is used\&. Consequently, if your custom padding policy modifies the property as a function of the previous value, e\&.g\&.: 
.PP
.nf
kernel.someProperty += 2;

.fi
.PP
.PP
then the second time the graph runs, the property may have an inconsistent value, leading to unexpected behavior\&. The default padding computation runs before the custom padding method to provide it with a sense of what is expected for the default configuration and will reinitialize the value in the case of the \&.offset\&. However, that computation usually doesn't reset other properties\&. In such cases, the custom padding policy may need to keep a record of the original value to enable consistent behavior\&. 
.SS "\- (\fBMPSNNImageNode\fP*) resultImage\fC [read]\fP, \fC [nonatomic]\fP, \fC [assign]\fP"
Get the node representing the image result of the filter  Except where otherwise noted, the precision used for the result image (see format property) is copied from the precision from the first input image node\&. 
.SS "\- (\fBMPSNNStateNode\fP*) resultState\fC [read]\fP, \fC [nonatomic]\fP, \fC [assign]\fP"
convenience method for resultStates[0]  If resultStates is nil, returns nil 
.SS "\- (NSArray<\fBMPSNNStateNode\fP*>*) resultStates\fC [read]\fP, \fC [nonatomic]\fP, \fC [assign]\fP"
Get the node representing the state result of the filter  If more than one, see description of subclass for ordering\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for MetalPerformanceShaders\&.framework from the source code\&.
